What does /proc/PID/ have?
==========================

/proc/[pid]

  There is a numerical subdirectory for each running process; the subdirectory is named by the process ID.

  Each  /proc/[pid] subdirectory contains the pseudo-files and directories described below.  These files are normally owned by the effective user and effective group ID
  of the process.  However, as a security measure, the ownership is made root:root if the process's "dumpable" attribute is set to a value other than 1.  This attribute
  may change for the following reasons:

  *  The attribute was explicitly set via the prctl(2) PR_SET_DUMPABLE operation.

  *  The attribute was reset to the value in the file /proc/sys/fs/suid_dumpable (described below), for the reasons described in prctl(2).

  Resetting the "dumpable" attribute to 1 reverts the ownership of the /proc/[pid]/* files to the process's real UID and real GID.


attr/
-----

  The  files  in  this  directory  provide an API for security modules.  The contents of this directory are files that can be read and written in order to set security-
  related attributes.  This directory was added to support SELinux, but the intention was that the API be general enough to support other  security  modules.   For  the
  purpose of explanation, examples of how SELinux uses these files are provided below.

  This directory is present only if the kernel was configured with CONFIG_SECURITY.


autogroup
---------

  Process's Autogroup (Task Group) Membership

  Since  Linux 2.6.38, the kernel provides a feature known as autogrouping to improve interactive desktop performance in the face of multiprocess, CPU-intensive workloads such
  as building the Linux kernel with large numbers of parallel build processes (i.e., the make(1) -j flag).

  This feature operates in conjunction with the CFS scheduler and requires a kernel that is configured with CONFIG_SCHED_AUTOGROUP.  On  a  running  system,  this  feature  is
  enabled  or disabled via the file /proc/sys/kernel/sched_autogroup_enabled; a value of 0 disables the feature, while a value of 1 enables it.  The default value in this file
  is 1, unless the kernel was booted with the noautogroup parameter.

  A new autogroup is created when a new session is created via setsid(2); this happens, for example, when a new terminal window is started.  A new process created  by  fork(2)
  inherits  its  parent's  autogroup  membership.  Thus, all of the processes in a session are members of the same autogroup.  An autogroup is automatically destroyed when the
  last process in the group terminates.

  When autogrouping is enabled, all of the members of an autogroup are placed in the same kernel scheduler "task group".  The CFS scheduler employs an algorithm that equalizes
  the distribution of CPU cycles across task groups.  The benefits of this for interactive desktop performance can be described via the following example.

  Suppose  that there are two autogroups competing for the same CPU (i.e., presume either a single CPU system or the use of taskset(1) to confine all the processes to the same
  CPU on an SMP system).  The first group contains ten CPU-bound processes from a kernel build started with make -j10.  The other contains a single CPU-bound process: a  video
  player.   The  effect  of autogrouping is that the two groups will each receive half of the CPU cycles.  That is, the video player will receive 50% of the CPU cycles, rather
  than just 9% of the cycles, which would likely lead to degraded video playback.  The situation on an SMP system is more complex, but the general  effect  is  the  same:  the
  scheduler  distributes  CPU  cycles  across  task groups such that an autogroup that contains a large number of CPU-bound processes does not end up hogging CPU cycles at the
  expense of the other jobs on the system.

  A process's autogroup (task group) membership can be viewed via the file /proc/[pid]/autogroup:

      $ cat /proc/1/autogroup
      /autogroup-1 nice 0

  This file can also be used to modify the CPU bandwidth allocated to an autogroup.  This is done by writing a number in the "nice" range to the file to  set  the  autogroup's
  nice value.  The allowed range is from +19 (low priority) to -20 (high priority).  (Writing values outside of this range causes write(2) to fail with the error EINVAL.)

  The  autogroup nice setting has the same meaning as the process nice value, but applies to distribution of CPU cycles to the autogroup as a whole, based on the relative nice
  values of other autogroups.  For a process inside an autogroup, the CPU cycles that it receives will be a product of the autogroup's nice  value  (compared  to  other  auto‐
  groups) and the process's nice value (compared to other processes in the same autogroup.

  The use of the cgroups(7) CPU controller to place processes in cgroups other than the root CPU cgroup overrides the effect of autogrouping.

  The  autogroup  feature groups only processes scheduled under non-real-time policies (SCHED_OTHER, SCHED_BATCH, and SCHED_IDLE).  It does not group processes scheduled under
  real-time and deadline policies.  Those processes are scheduled according to the rules described earlier.


auxv
----

  This contains the contents of the ELF interpreter information passed to the process at exec time.  The format is one unsigned long ID plus one unsigned long value for
  each entry.  The last entry contains two zeros.  See also getauxval(3).

  Permission to access this file is governed by a ptrace access mode PTRACE_MODE_READ_FSCREDS check; see ptrace(2).


cgroup
------

  See cgroups(7).


clear_refs
----------

  This is a write-only file, writable only by owner of the process.

  The following values may be written to the file:

  1 (since Linux 2.6.22)
         Reset  the  PG_Referenced and ACCESSED/YOUNG bits for all the pages associated with the process.  (Before kernel 2.6.32, writing any nonzero value to this file
         had this effect.)

  2 (since Linux 2.6.32)
         Reset the PG_Referenced and ACCESSED/YOUNG bits for all anonymous pages associated with the process.

  3 (since Linux 2.6.32)
         Reset the PG_Referenced and ACCESSED/YOUNG bits for all file-mapped pages associated with the process.

  Clearing the PG_Referenced and ACCESSED/YOUNG bits provides a method to measure approximately how much memory a process is using.  One first inspects  the  values  in
  the  "Referenced"  fields  for  the  VMAs  shown  in  /proc/[pid]/smaps  to get an idea of the memory footprint of the process.  One then clears the PG_Referenced and
  ACCESSED/YOUNG bits and, after some measured time interval, once again inspects the values in the "Referenced" fields to get an idea of the change in memory footprint
  of the process during the measured interval.  If one is interested only in inspecting the selected mapping types, then the value 2 or 3 can be used instead of 1.

  Further values can be written to affect different properties:

  4 (since Linux 3.11)
         Clear the soft-dirty bit for all the pages associated with the process.  This is used (in conjunction with /proc/[pid]/pagemap) by the check-point restore sys‐
         tem to discover which pages of a process have been dirtied since the file /proc/[pid]/clear_refs was written to.

  5 (since Linux 4.0)
         Reset the peak resident set size ("high water mark") to the process's current resident set size value.

  Writing any value to /proc/[pid]/clear_refs other than those listed above has no effect.

  The /proc/[pid]/clear_refs file is present only if the CONFIG_PROC_PAGE_MONITOR kernel configuration option is enabled.


cmdline
-------

  This read-only file holds the complete command line for the process, unless the process is a zombie.  In the latter case, there is nothing in this file:  that  is,  a
  read  on  this  file will return 0 characters.  The command-line arguments appear in this file as a set of strings separated by null bytes ('\0'), with a further null
  byte after the last string.

  When the process is started by the kernel, cmdline is NUL-separated, and the kernel code simply copies the range of memory where argv[] was at process startup into the
  output buffer when you read /proc/PID/cmdline.

  e.g.
  I once met a problem where /proc/PID/cmdline contains incorrect value. It turns out that I was using an uninitialzed char *s in program.
  The codes are like:
  {
	char *s;
	...
	sprintf(s, "%d\n", getpid());
	...
  }
  And it's incorrectly writing to memory that should be used by argv.
  To fix the problem, use char s[16] instead of char *s.


comm
----

  This file exposes the process's comm value—that is, the command name associated with the process.  Different threads in the same process may have different comm  val‐
  ues,  accessible  via /proc/[pid]/task/[tid]/comm.  A thread may modify its comm value, or that of any of other thread in the same thread group (see the discussion of
  CLONE_THREAD in clone(2)), by writing to the file /proc/self/task/[tid]/comm.  Strings longer than TASK_COMM_LEN (16) characters are silently truncated.

  This file provides a superset of the prctl(2) PR_SET_NAME and PR_GET_NAME operations, and is employed by pthread_setname_np(3) when used to rename threads other  than
  the caller.


coredump_filter
---------------

  See core(5).


cpuset
------

  See cpuset(7).


cwd@
----

  This is a symbolic link to the current working directory of the process.  To find out the current working directory of process 20, for instance, you can do this:

      $ cd /proc/20/cwd; /bin/pwd

  Note that the pwd command is often a shell built-in, and might not work properly.  In bash(1), you may use pwd -P.

  In a multithreaded process, the contents of this symbolic link are not available if the main thread has already terminated (typically by calling pthread_exit(3)).

  Permission to dereference or read (readlink(2)) this symbolic link is governed by a ptrace access mode PTRACE_MODE_READ_FSCREDS check; see ptrace(2).


environ
-------

  This  file  contains  the  initial  environment  that was set when the currently executing program was started via execve(2).  The entries are separated by null bytes
  ('\0'), and there may be a null byte at the end.  Thus, to print out the environment of process 1, you would do:

      $ strings /proc/1/environ

  If, after an execve(2), the process modifies its environment (e.g., by calling functions such as putenv(3) or modifying the environ(7) variable directly),  this  file
  will not reflect those changes.

  Furthermore, a process may change the memory location that this file refers via prctl(2) operations such as PR_SET_MM_ENV_START.

  Permission to access this file is governed by a ptrace access mode PTRACE_MODE_READ_FSCREDS check; see ptrace(2).

  In fact, when using `strings' command to examine the /proc/PID/environ file, '-w' option is needed to get correct output in case '\n' is in some value.


exe@
----

  Under  Linux  2.2  and  later,  this file is a symbolic link containing the actual pathname of the executed command.  This symbolic link can be dereferenced normally;
  attempting to open it will open the executable.  You can even type /proc/[pid]/exe to run another copy of the same executable that is being run by process [pid].   If
  the  pathname has been unlinked, the symbolic link will contain the string '(deleted)' appended to the original pathname.  In a multithreaded process, the contents of
  this symbolic link are not available if the main thread has already terminated (typically by calling pthread_exit(3)).

  Permission to dereference or read (readlink(2)) this symbolic link is governed by a ptrace access mode PTRACE_MODE_READ_FSCREDS check; see ptrace(2).

  Under Linux 2.0 and earlier, /proc/[pid]/exe is a pointer to the binary which was executed, and appears as a symbolic link.  A readlink(2) call  on  this  file  under
  Linux 2.0 returns a string in the format:

      [device]:inode

  For example, [0301]:1502 would be inode 1502 on device major 03 (IDE, MFM, etc. drives) minor 01 (first partition on the first drive).

  find(1) with the -inum option can be used to locate the file.


fd/
---

  This  is  a subdirectory containing one entry for each file which the process has open, named by its file descriptor, and which is a symbolic link to the actual file.
  Thus, 0 is standard input, 1 standard output, 2 standard error, and so on.

  For file descriptors for pipes and sockets, the entries will be symbolic links whose content is the file type with the inode.  A readlink(2) call on this file returns
  a string in the format:

      type:[inode]

  For  example,  socket:[2248868]  will  be  a  socket and its inode is 2248868.  For sockets, that inode can be used to find more information in one of the files under
  /proc/net/.

  For file descriptors that have no corresponding inode (e.g., file descriptors produced by bpf(2), epoll_create(2),  eventfd(2),  inotify_init(2),  perf_event_open(2),
  signalfd(2), timerfd_create(2), and userfaultfd(2)), the entry will be a symbolic link with contents of the form

      anon_inode:<file-type>

  In many cases (but not all), the file-type is surrounded by square brackets.

  For example, an epoll file descriptor will have a symbolic link whose content is the string anon_inode:[eventpoll].

  In a multithreaded process, the contents of this directory are not available if the main thread has already terminated (typically by calling pthread_exit(3)).

  Programs that take a filename as a command-line argument, but don't take input from standard input if no argument is supplied, and programs that write to a file named
  as a command-line argument, but don't send their output to standard output if no argument is supplied, can nevertheless be made to use standard input or standard out‐
  put  by  using  /proc/[pid]/fd files as command-line arguments.  For example, assuming that -i is the flag designating an input file and -o is the flag designating an
  output file:

      $ foobar -i /proc/self/fd/0 -o /proc/self/fd/1 ...

  and you have a working filter.

  /proc/self/fd/N is approximately the same as /dev/fd/N in some UNIX and UNIX-like systems.  Most Linux MAKEDEV scripts symbolically link /dev/fd to /proc/self/fd,  in
  fact.

  Most  systems  provide  symbolic  links /dev/stdin, /dev/stdout, and /dev/stderr, which respectively link to the files 0, 1, and 2 in /proc/self/fd.  Thus the example
  command above could be written as:

      $ foobar -i /dev/stdin -o /dev/stdout ...

  Permission to dereference or read (readlink(2)) the symbolic links in this directory  is  governed  by  a  ptrace  access  mode  PTRACE_MODE_READ_FSCREDS  check;  see
  ptrace(2).


fdinfo/
-------

  This  is a subdirectory containing one entry for each file which the process has open, named by its file descriptor.  The files in this directory are readable only by
  the owner of the process.  The contents of each file can be read to obtain information about the corresponding file descriptor.  The content depends on  the  type  of
  file referred to by the corresponding file descriptor.

  For regular files and directories, we see something like:

      $ cat /proc/12015/fdinfo/4
      pos:    1000
      flags:  01002002
      mnt_id: 21

  The fields are as follows:

  pos    This is a decimal number showing the file offset.

  flags  This  is  an octal number that displays the file access mode and file status flags (see open(2)).  If the close-on-exec file descriptor flag is set, then flags
         will also include the value O_CLOEXEC.

         Before Linux 3.1, this field incorrectly displayed the setting of O_CLOEXEC at the time the file was opened, rather than the current setting of  the  close-on-
         exec flag.

  mnt_id This field, present since Linux 3.15, is the ID of the mount point containing this file.  See the description of /proc/[pid]/mountinfo.

  For eventfd file descriptors (see eventfd(2)), we see (since Linux 3.8) the following fields:

      pos: 0
      flags:    02
      mnt_id:   10
      eventfd-count:               40

  eventfd-count is the current value of the eventfd counter, in hexadecimal.

  For epoll file descriptors (see epoll(7)), we see (since Linux 3.8) the following fields:

      pos: 0
      flags:    02
      mnt_id:   10
      tfd:        9 events:       19 data: 74253d2500000009
      tfd:        7 events:       19 data: 74253d2500000007

  Each  of  the  lines  beginning  tfd describes one of the file descriptors being monitored via the epoll file descriptor (see epoll_ctl(2) for some details).  The tfd
  field is the number of the file descriptor.  The events field is a hexadecimal mask of the events being monitored for this file descriptor.  The  data  field  is  the
  data value associated with this file descriptor.

  For signalfd file descriptors (see signalfd(2)), we see (since Linux 3.8) the following fields:

      pos: 0
      flags:    02
      mnt_id:   10
      sigmask:  0000000000000006

  sigmask  is the hexadecimal mask of signals that are accepted via this signalfd file descriptor.  (In this example, bits 2 and 3 are set, corresponding to the signals
  SIGINT and SIGQUIT; see signal(7).)

  For inotify file descriptors (see inotify(7)), we see (since Linux 3.8) the following fields:

      pos: 0
      flags:    00
      mnt_id:   11
      inotify wd:2 ino:7ef82a sdev:800001 mask:800afff ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:2af87e00220ffd73
      inotify wd:1 ino:192627 sdev:800001 mask:800afff ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:27261900802dfd73

  Each of the lines beginning with "inotify" displays information about one file or directory that is being monitored.  The fields in this line are as follows:

  wd     A watch descriptor number (in decimal).

  ino    The inode number of the target file (in hexadecimal).

  sdev   The ID of the device where the target file resides (in hexadecimal).

  mask   The mask of events being monitored for the target file (in hexadecimal).

  If the kernel was built with exportfs support, the path to the target file is exposed as a file handle, via three hexadecimal fields: fhandle-bytes, fhandle-type, and
  f_handle.

  For fanotify file descriptors (see fanotify(7)), we see (since Linux 3.8) the following fields:

      pos: 0
      flags:    02
      mnt_id:   11
      fanotify flags:0 event-flags:88002
      fanotify ino:19264f sdev:800001 mflags:0 mask:1 ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:4f261900a82dfd73

  The fourth line displays information defined when the fanotify group was created via fanotify_init(2):

  flags  The flags argument given to fanotify_init(2) (expressed in hexadecimal).

  event-flags
         The event_f_flags argument given to fanotify_init(2) (expressed in hexadecimal).

  Each additional line shown in the file contains information about one of the marks in the fanotify group.  Most of these fields are as for inotify, except:

  mflags The flags associated with the mark (expressed in hexadecimal).

  mask   The events mask for this mark (expressed in hexadecimal).

  ignored_mask
         The mask of events that are ignored for this mark (expressed in hexadecimal).

  For details on these fields, see fanotify_mark(2).




gid_map
io
latency
limits
loginuid
map_files/
maps
mem
mountinfo
mounts
mountstats
net/
ns/
numa_maps
oom_adj
oom_score
oom_score_adj
pagemap
personality
projid_map
root@
sched
schedstat
sessionid
setgroups
smaps
stack
stat
statm
status
syscall
task/
timers
timerslack_ns
uid_map
wchan
